<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tesla Dashboard with Valhalla Routing</title>

  <link href="https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.css" rel="stylesheet" />
  <style>
    html, body { margin: 0; padding: 0; height: 100%; }
    #map { width: 100vw; height: 100vh; filter: brightness(0.85); }

    #destination-input {
      position: fixed;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 999;
      background: #222;
      padding: 8px;
      border-radius: 6px;
      display: flex;
      gap: 8px;
      align-items: center;
      box-shadow: 0 0 10px #000;
    }
    #destination-input input {
      width: 250px;
      padding: 6px;
      border: none;
      border-radius: 4px;
      font-size: 14px;
    }
    #destination-input button {
      padding: 6px 10px;
      background: #444;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    #etaDisplay {
      position: fixed;
      bottom: 60px;
      right: 20px;
      background: #222;
      color: white;
      padding: 8px 12px;
      border-radius: 6px;
      z-index: 999;
      display: none;
      font-family: monospace;
    }
    #bottom-buttons {
      position: fixed;
      bottom: 0;
      width: 100%;
      background: #111;
      display: flex;
      justify-content: space-around;
      padding: 12px 0;
      z-index: 999;
    }
    #bottom-buttons button {
      color: white;
      background: transparent;
      border: none;
      font-size: 16px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <div id="destination-input">
    <input type="text" id="destination" placeholder="Enter destination" />
    <button onclick="findDestination()">Go</button>
  </div>

  <div id="etaDisplay">ETA:</div>

  <div id="bottom-buttons">
    <button>Home</button>
    <button>Music</button>
    <button>Navigation</button>
  </div>

  <script src="https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.js"></script>
  <script>
    let map;
    let userMarker;
    let routeLine;

    map = new maplibregl.Map({
      container: 'map',
      style: 'https://api.maptiler.com/maps/streets-dark/style.json?key=Uqv6nV8Kjh3iKtp4AvsU', // MapTiler free dark style
      center: [-95.3698, 29.7604],
      zoom: 13
    });

    // Show live user location
    if (navigator.geolocation) {
      navigator.geolocation.watchPosition(pos => {
        const coords = [pos.coords.longitude, pos.coords.latitude];
        map.setCenter(coords);

        if (!userMarker) {
          userMarker = new maplibregl.Marker({ color: "#00FF00" }).setLngLat(coords).addTo(map);
        } else {
          userMarker.setLngLat(coords);
        }
      });
    }

    function findDestination() {
      const query = document.getElementById("destination").value.trim();
      if (!query) return alert("Enter a destination");

      // Photon API geocode
      fetch(`https://photon.komoot.io/api/?q=${encodeURIComponent(query)}&limit=1`)
        .then(res => res.json())
        .then(data => {
          if (!data.features.length) {
            alert("Place not found");
            return;
          }
          const [lon, lat] = data.features[0].geometry.coordinates;
          getRouteToDestination([lat, lon]);
        });
    }

    // Decode Valhalla polyline (encoded in flexible polyline format)
    // Source: https://github.com/opening-hours/polyline  
    // We'll include a simple decoder below

    // Flexible Polyline Decoder (simplified)
    // You can find official at: https://github.com/opening-hours/polyline
    function decodePolyline(encoded) {
      const decode = (str) => {
        const result = [];
        let index = 0, len = str.length;
        let lat = 0, lng = 0;
        while (index < len) {
          let shift = 0, b, delta = 0;
          do {
            b = str.charCodeAt(index++) - 63;
            delta |= (b & 0x1f) << shift;
            shift += 5;
          } while (b >= 0x20);
          const dlat = (delta & 1) ? ~(delta >> 1) : (delta >> 1);
          lat += dlat;

          shift = 0; delta = 0;
          do {
            b = str.charCodeAt(index++) - 63;
            delta |= (b & 0x1f) << shift;
            shift += 5;
          } while (b >= 0x20);
          const dlng = (delta & 1) ? ~(delta >> 1) : (delta >> 1);
          lng += dlng;

          result.push([lng * 1e-5, lat * 1e-5]);
        }
        return result;
      };
      return decode(encoded);
    }

    function getRouteToDestination(destLatLon) {
      if (!userMarker) {
        alert("Waiting for your location...");
        return;
      }
      const originLngLat = userMarker.getLngLat();

      const body = {
        locations: [
          { lat: originLngLat.lat, lon: originLngLat.lng },
          { lat: destLatLon[0], lon: destLatLon[1] }
        ],
        costing: "auto",
        directions_options: { units: "miles" }
      };

      fetch(`https://valhalla1.openstreetmap.de/route?json=${encodeURIComponent(JSON.stringify(body))}`)
        .then(res => res.json())
        .then(data => {
          if (data.trip) {
            const durationMin = Math.round(data.trip.summary.time / 60);
            document.getElementById("etaDisplay").style.display = "block";
            document.getElementById("etaDisplay").innerText = `ETA: ${durationMin} min`;

            // Decode the polyline shape from valhalla response
            const shape = data.trip.legs[0].shape; // flexible polyline encoded string
            const coords = decodePolyline(shape).map(c => [c[0], c[1]]); // [lng, lat]

            // Remove previous route if any
            if (map.getLayer('route')) {
              map.removeLayer('route');
              map.removeSource('route');
            }

            map.addSource('route', {
              type: 'geojson',
              data: {
                type: 'Feature',
                geometry: {
                  type: 'LineString',
                  coordinates: coords
                }
              }
            });

            map.addLayer({
              id: 'route',
              type: 'line',
              source: 'route',
              layout: { 'line-join': 'round', 'line-cap': 'round' },
              paint: { 'line-color': '#00FF00', 'line-width': 5 }
            });

            // Fit map to route bounds
            const bounds = coords.reduce((b, coord) => b.extend(coord), new maplibregl.LngLatBounds(coords[0], coords[0]));
            map.fitBounds(bounds, { padding: 50 });
          } else {
            alert("Routing error");
          }
        })
        .catch(() => alert("Routing failed"));
    }
  </script>
</body>
</html>
